import os
import json
import docker
import threading
from typing import Dict, Any, Optional

# Import Pydantic models
from backend.models.questions import DockerRunRequest

# Import language configuration
from backend.code_testing.language_config import LANGUAGE_CONFIG


# Global Docker client and persistent containers
_docker_client = None
_persistent_containers = {}
_container_lock = threading.Lock()


def get_docker_client():
    global _docker_client
    if _docker_client is None:
        _docker_client = docker.from_env()
    return _docker_client


def use_java_compilation_server(container, source_code):
    """
    Use the Java compilation server to compile source code.
    Returns the compilation output directory path, or None if compilation failed.
    """
    try:
        # Check if compilation server is ready
        if (
            not hasattr(container, "_java_compilation_server_ready")
            or not container._java_compilation_server_ready
        ):
            print("‚ùå [COMPILATION SERVER] Server not ready")
            return None

        import socket
        import time

        compile_start = time.time()
        print(
            f"üî• [COMPILATION SERVER] Sending {len(source_code)} chars to compilation server"
        )

        # Create socket connection via docker exec (since container has no network)
        # We'll use a temporary script to handle the TCP communication
        import base64

        # Encode source code for safe transmission
        encoded_source = base64.b64encode(source_code.encode("utf-8")).decode("ascii")

        # Original working approach that achieved 600ms performance
        comm_script = f"""#!/bin/bash
# Connect to compilation server and send source code
exec 3<>/dev/tcp/localhost/8901

# Send source code length
echo "{len(source_code)}" >&3

# Send base64-encoded source code and decode it
echo "{encoded_source}" | base64 -d >&3

# Read response
read -u 3 status
read -u 3 result

echo "STATUS:$status"
echo "RESULT:$result"

exec 3<&-
exec 3>&-
"""

        # Write and execute communication script (original approach)
        script_encoded = base64.b64encode(comm_script.encode()).decode()
        script_create = container.exec_run(
            f"sh -c 'echo {script_encoded} | base64 -d > /tmp/compile_comm.sh && chmod +x /tmp/compile_comm.sh'",
            workdir="/tmp",
        )

        if script_create.exit_code != 0:
            print(f"‚ùå [COMPILATION SERVER] Failed to create communication script")
            return None

        # Execute the communication script with timeout
        comm_result = container.exec_run(f"bash /tmp/compile_comm.sh", workdir="/tmp")

        compile_time = (time.time() - compile_start) * 1000
        print(f"üî• [COMPILATION SERVER] Communication took {compile_time:.0f}ms")

        if comm_result.exit_code != 0:
            print(
                f"‚ùå [COMPILATION SERVER] Communication failed: {comm_result.output.decode()}"
            )
            return None

        # Parse response
        output = comm_result.output.decode("utf-8").strip()
        lines = output.split("\n")

        status_line = None
        result_line = None

        for line in lines:
            if line.startswith("STATUS:"):
                status_line = line[7:]  # Remove "STATUS:" prefix
            elif line.startswith("RESULT:"):
                result_line = line[7:]  # Remove "RESULT:" prefix

        if status_line == "SUCCESS" and result_line:
            print(
                f"‚úÖ [COMPILATION SERVER] Compilation successful, output: {result_line}"
            )
            return result_line
        else:
            print(f"‚ùå [COMPILATION SERVER] Compilation failed: {result_line}")
            return None

    except Exception as e:
        print(f"‚ùå [COMPILATION SERVER] Error: {e}")
        return None


def compile_cpp_with_cache(container, source_code, function_name):
    """
    Compile C++ code with smart caching for fast subsequent executions.
    Returns the compiled binary path, or None if compilation failed.
    """
    try:
        import hashlib
        import time
        import base64

        cache_start = time.time()

        # Generate cache key from source content
        source_hash = hashlib.md5(source_code.encode()).hexdigest()[
            :16
        ]  # Use first 16 chars
        binary_name = f"cached_{function_name}_{source_hash}"
        binary_path = f"/tmp/{binary_name}"

        # Check if binary already exists (cache hit)
        check_cache = container.exec_run(f"test -f {binary_path}", workdir="/tmp")
        if check_cache.exit_code == 0:
            cache_time = (time.time() - cache_start) * 1000
            print(
                f"üöÄ [CPP CACHE] Cache hit! Using cached binary: {binary_name} ({cache_time:.1f}ms)"
            )
            return binary_path

        # Cache miss - need to compile
        print(f"üîß [CPP CACHE] Cache miss, compiling {function_name}...")

        # First, write the source code to a temporary file for compilation
        temp_filename = f"cache_source_{source_hash}.cpp"
        encoded_source = base64.b64encode(source_code.encode("utf-8")).decode("ascii")

        create_result = container.exec_run(
            f"sh -c 'echo {encoded_source} | base64 -d > /tmp/{temp_filename}'",
            workdir="/tmp",
        )

        if create_result.exit_code != 0:
            print(
                f"‚ùå [CPP CACHE] Failed to create source file: {create_result.output.decode()}"
            )
            return None

        compile_start = time.time()

        # Compile with optimized flags for faster compilation and execution
        compile_cmd = f"g++ -std=c++17 -O2 -pipe -o {binary_path} {temp_filename}"
        compile_result = container.exec_run(f"{compile_cmd}", workdir="/tmp")

        compile_time = (time.time() - compile_start) * 1000

        # Clean up temporary source file
        container.exec_run(f"rm -f /tmp/{temp_filename}", workdir="/tmp")

        # Handle timeout error for compilation
        if compile_result.exit_code == 124:
            print(f"‚ùå [CPP CACHE] Compilation timed out")
            return None

        if compile_result.exit_code == 0:
            print(
                f"‚úÖ [CPP CACHE] Compiled and cached binary: {binary_name} ({compile_time:.1f}ms)"
            )
            return binary_path
        else:
            error_output = compile_result.output.decode()
            print(f"‚ùå [CPP CACHE] Compilation failed: {error_output}")
            return None

    except Exception as e:
        print(f"‚ùå [CPP CACHE] Caching failed: {e}")
        return None


def extract_java_imports(user_code):
    """
    Extract import statements from Java user code and return cleaned code + imports.
    Returns: (cleaned_code, imports_list)
    """
    import re

    # Find all import statements
    import_pattern = r"^import\s+[^;]+;"
    imports = []

    lines = user_code.split("\n")
    cleaned_lines = []

    for line in lines:
        stripped_line = line.strip()
        if re.match(import_pattern, stripped_line):
            imports.append(stripped_line)
            print(f"üîß [JAVA IMPORTS] Extracted: {stripped_line}")
        else:
            cleaned_lines.append(line)

    cleaned_code = "\n".join(cleaned_lines)

    # Remove empty lines at the beginning that were left by removed imports
    cleaned_code = re.sub(r"^\n+", "", cleaned_code)

    return cleaned_code, imports


def generate_cpp_wrapper(function_name, user_code):
    """
    Generate C++ wrapper using problem-specific harnesses from cpp_harnesses directory.
    This replaces the complex if/else wrapper system with a clean harness-based approach.
    """
    import os
    import re

    # Map function names to their harness directory names
    # This maps the function name to the directory in cpp_harnesses/harnesses/
    function_to_harness = {
        "twoSum": "two-sum",
        "fizzBuzz": "fizz-buzz",
        "addBinary": "add-binary",
        "addTwoNumbers": "add-two-numbers",
        "maxProfit": "best-time-to-buy-and-sell-stock",
        "climbStairs": "climbing-stairs",
        "coinChange": "coin-change",
        "maxArea": "container-with-most-water",
        "containsDuplicate": "contains-duplicate",
        "firstBadVersion": "first-bad-version",
        "groupAnagrams": "group-anagrams",
        "rob": "house-robber",
        "intersection": "intersection-of-two-arrays",
        "invertTree": "invert-binary-tree",
        "lengthOfLongestSubstring": "longest-substring-without-repeating-characters",
        "majorityElement": "majority-element",
        "maxDepth": "maximum-depth-of-binary-tree",
        "merge": "merge-intervals",
        "mergeTwoLists": "merge-two-sorted-lists",
        "minDistance": "edit-distance",
        "missingNumber": "missing-number",
        "isPalindrome": "palindrome-number",
        "isPowerOfTwo": "power-of-two",
        "productExceptSelf": "product-of-array-except-self",
        "removeDuplicates": "remove-duplicates-from-sorted-array",
        "reverse": "reverse-integer",
        "isSameTree": "same-tree",
        "singleNumber": "single-number",
        "topKFrequent": "top-k-frequent-elements",
        "isValid": "valid-parentheses",
        "isAnagram": "valid-anagram",
        "threeSum": "3sum",
        "ladderLength": "word-ladder",
        "wordBreak": "word-break-ii",
        "maxCoins": "burst-balloons",
        "minCut": "palindrome-partitioning-ii",
        "minDistance": "edit-distance",
        "alienOrder": "alien-dictionary",
        "trap": "trapping-rain-water",
        "findMedianSortedArrays": "median-of-two-sorted-arrays",
        "findAnagrams": "find-all-anagrams-in-a-string",
        "subarraySum": "subarray-sum-equals-k",
        "rotate": "rotate-image",
    }

    harness_name = function_to_harness.get(function_name)
    if not harness_name:
        print(f"‚ùå [CPP HARNESS] No harness found for function: {function_name}")
        # Fallback to basic wrapper (we'll implement this below)
        return generate_cpp_basic_wrapper(function_name, user_code)

    # Get harness directory path
    base_dir = os.path.dirname(__file__)
    harness_dir = os.path.join(base_dir, "cpp_harnesses", "harnesses", harness_name)
    userfunc_path = os.path.join(harness_dir, "userfunc.h")
    harness_path = os.path.join(harness_dir, "harness.cpp")

    try:
        # Read harness files
        with open(userfunc_path, "r") as f:
            userfunc_content = f.read()
        with open(harness_path, "r") as f:
            harness_content = f.read()

        print(f"‚úÖ [CPP HARNESS] Found harness for {function_name} -> {harness_name}")

        # Combine user code with harness
        # The harness.cpp includes "userfunc.h" which contains the Solution class declaration
        # User code should provide the Solution class implementation
        # We need to replace the userfunc.h include with the combined header + user implementation

        # Remove the #include "userfunc.h" from harness and replace with direct content
        harness_without_include = harness_content.replace('#include "userfunc.h"', "")

        # Extract header content (everything except the class declaration)
        userfunc_lines = userfunc_content.split("\n")
        header_lines = []
        solution_class_found = False

        for line in userfunc_lines:
            if "class Solution" in line:
                solution_class_found = True
                break
            header_lines.append(line)

        header_content = "\n".join(header_lines)

        combined_code = f"""// Generated wrapper using harness: {harness_name}
{header_content}

// User provided Solution class implementation
{user_code}

// Generated harness code
{harness_without_include}
"""

        return combined_code

    except FileNotFoundError as e:
        print(f"‚ùå [CPP HARNESS] Harness files not found for {harness_name}: {e}")
        return generate_cpp_basic_wrapper(function_name, user_code)
    except Exception as e:
        print(f"‚ùå [CPP HARNESS] Error loading harness for {harness_name}: {e}")
        return generate_cpp_basic_wrapper(function_name, user_code)


def generate_cpp_basic_wrapper(function_name, user_code):
    """
    Basic C++ wrapper fallback for when no specific harness is available.
    """
    print(f"üîß [CPP BASIC] Using basic wrapper for {function_name}")

    basic_wrapper = f"""
#include <bits/stdc++.h>
using namespace std;

// Basic data structures
struct ListNode {{
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {{}}
    ListNode(int x) : val(x), next(nullptr) {{}}
    ListNode(int x, ListNode *next) : val(x), next(next) {{}}
}};

struct TreeNode {{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {{}}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {{}}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {{}}
}};

// User code
{user_code}

// Basic main function
int main(int argc, char** argv) {{
    if(argc < 3) {{
        cout << "{{\\"result\\":\\"Missing arguments\\",\\"execution_time\\":0}}" << endl;
        return 1;
    }}
    
    // Basic JSON parsing would go here
    cout << "{{\\"result\\":\\"Basic wrapper - please implement harness for {function_name}\\",\\"execution_time\\":0}}" << endl;
    return 0;
}}
"""
    return basic_wrapper


def generate_java_wrapper(function_name, user_code):
    """
    Generate Java wrapper that injects main method into user's public class Solution.
    This allows users to use 'public class Solution' without file naming conflicts.
    """

    # Extract imports from user code
    cleaned_code, user_imports = extract_java_imports(user_code)
    user_imports_str = "\n".join(user_imports) if user_imports else ""

    # Check if user code has 'class Solution' (with or without public)
    import re

    if re.search(r"(public\s+)?class\s+Solution", cleaned_code):
        print(f"üîß [JAVA WRAPPER] User has Solution class, injecting main method")

        # Find the end of the Solution class to inject main method
        # Simple approach: find the last closing brace and inject before it
        lines = cleaned_code.split("\n")

        # Find the last non-empty line with closing brace
        last_brace_line = -1
        for i in range(len(lines) - 1, -1, -1):
            stripped_line = lines[i].strip()
            if stripped_line == "}" and last_brace_line == -1:
                last_brace_line = i
                break

        if last_brace_line != -1:
            # Inject main method before the last closing brace
            main_method = """
    // Injected main method for wrapper functionality
    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println("{\\"result\\": \\"Missing arguments: expected method name and input data\\", \\"execution_time\\": 0}");
            return;
        }
        
        String methodName = args[0];
        String inputJson = args[1];
        long startTime = System.nanoTime();
        
        try {
            Solution sol = new Solution();
            Object result = null;
            
            // Special handling for first-bad-version problem
            if ("firstBadVersion".equals(methodName)) {
                int n = TestRunner.extractIntValue(inputJson, "n");
                int bad = TestRunner.extractIntValue(inputJson, "bad");
                
                VersionControl.setBadVersion(bad);
                
                java.lang.reflect.Method method = Solution.class.getMethod("firstBadVersion", int.class);
                result = method.invoke(sol, n);
            } else if ("rotate".equals(methodName)) {
                // Special handling for rotate method which modifies matrix in place
                int[][] matrix = TestRunner.extractIntMatrix(inputJson, "matrix");
                java.lang.reflect.Method method = Solution.class.getMethod("rotate", int[][].class);
                method.invoke(sol, (Object) matrix);
                result = matrix; // Return the modified matrix
            } else {
                // Generic method calling using reflection
                java.lang.reflect.Method targetMethod = null;
                java.lang.reflect.Method[] methods = Solution.class.getMethods();
                for (java.lang.reflect.Method method : methods) {
                    if (method.getName().equals(methodName)) {
                        targetMethod = method;
                        break;
                    }
                }
                
                if (targetMethod == null) {
                    throw new RuntimeException("Method " + methodName + " not found in Solution class");
                }
                
                Object[] params = extractParametersInJsonOrder(inputJson);
                result = targetMethod.invoke(sol, params);
            }
            
            long endTime = System.nanoTime();
            double executionTime = (endTime - startTime) / 1_000_000.0;
            
            // Format output
            if (result instanceof int[][]) {
                int[][] matrix = (int[][]) result;
                StringBuilder sb = new StringBuilder("[");
                for (int i = 0; i < matrix.length; i++) {
                    if (i > 0) sb.append(", ");
                    sb.append("[");
                    for (int j = 0; j < matrix[i].length; j++) {
                        if (j > 0) sb.append(", ");
                        sb.append(matrix[i][j]);
                    }
                    sb.append("]");
                }
                sb.append("]");
                System.out.println("{\\"result\\": " + sb.toString() + ", \\"execution_time\\": " + executionTime + "}");
            } else if (result instanceof int[]) {
                int[] arr = (int[]) result;
                StringBuilder sb = new StringBuilder("[");
                for (int i = 0; i < arr.length; i++) {
                    if (i > 0) sb.append(", ");
                    sb.append(arr[i]);
                }
                sb.append("]");
                System.out.println("{\\"result\\": " + sb.toString() + ", \\"execution_time\\": " + executionTime + "}");
            } else if (result instanceof java.util.List) {
                java.util.List<?> list = (java.util.List<?>) result;
                // Check if this is a List<List<String>> (like group-anagrams)
                boolean isListOfLists = !list.isEmpty() && list.get(0) instanceof java.util.List;
                
                if (isListOfLists) {
                    // Handle List<List<String>>
                    StringBuilder sb = new StringBuilder("[");
                    for (int i = 0; i < list.size(); i++) {
                        if (i > 0) sb.append(", ");
                        java.util.List<?> innerList = (java.util.List<?>) list.get(i);
                        sb.append("[");
                        for (int j = 0; j < innerList.size(); j++) {
                            if (j > 0) sb.append(", ");
                            Object item = innerList.get(j);
                            if (item instanceof String) {
                                sb.append("\\"").append(item.toString().replace("\\"", "\\\\\\"")).append("\\"");
                            } else {
                                sb.append(item.toString());
                            }
                        }
                        sb.append("]");
                    }
                    sb.append("]");
                    System.out.println("{\\"result\\": " + sb.toString() + ", \\"execution_time\\": " + executionTime + "}");
                } else {
                    // Handle regular List<String> or List<Integer>
                    StringBuilder sb = new StringBuilder("[");
                    for (int i = 0; i < list.size(); i++) {
                        if (i > 0) sb.append(", ");
                        Object item = list.get(i);
                        if (item instanceof String) {
                            sb.append("\\"").append(item.toString().replace("\\"", "\\\\\\"")).append("\\"");
                        } else {
                            sb.append(item.toString());
                        }
                    }
                    sb.append("]");
                    System.out.println("{\\"result\\": " + sb.toString() + ", \\"execution_time\\": " + executionTime + "}");
                }
            } else if (result instanceof Integer) {
                System.out.println("{\\"result\\": " + result + ", \\"execution_time\\": " + executionTime + "}");
            } else if (result instanceof Boolean) {
                System.out.println("{\\"result\\": " + result + ", \\"execution_time\\": " + executionTime + "}");
            } else if (result instanceof String) {
                System.out.println("{\\"result\\": \\"" + result.toString().replace("\\"", "\\\\\\"") + "\\", \\"execution_time\\": " + executionTime + "}");
            } else if (result instanceof TreeNode) {
                // Serialize TreeNode to array format
                java.util.List<Object> treeArray = new java.util.ArrayList<>();
                TestRunner.serializeTreeNode((TreeNode) result, treeArray);
                StringBuilder sb = new StringBuilder("[");
                for (int i = 0; i < treeArray.size(); i++) {
                    if (i > 0) sb.append(", ");
                    if (treeArray.get(i) == null) {
                        sb.append("null");
                    } else {
                        sb.append(treeArray.get(i).toString());
                    }
                }
                sb.append("]");
                System.out.println("{\\"result\\": " + sb.toString() + ", \\"execution_time\\": " + executionTime + "}");
            } else {
                System.out.println("{\\"result\\": \\"" + String.valueOf(result).replace("\\"", "\\\\\\"") + "\\", \\"execution_time\\": " + executionTime + "}");
            }
            
        } catch (Exception e) {
            long endTime = System.nanoTime();
            double executionTime = (endTime - startTime) / 1_000_000.0;
            System.out.println("{\\"result\\": \\"" + e.getMessage().replace("\\"", "\\\\\\"") + "\\", \\"execution_time\\": " + executionTime + "}");
        }
    }
    
    // Helper methods
    private static int extractIntValue(String json, String key) {
        String pattern = "\\"" + key + "\\"\\\\s*:\\\\s*(-?\\\\d+)";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher m = p.matcher(json);
        if (m.find()) {
            return Integer.parseInt(m.group(1));
        }
        throw new RuntimeException("Could not find key: " + key);
    }
    
    private static Object[] extractParametersInJsonOrder(String json) {
        java.util.List<Object> params = new java.util.ArrayList<>();
        
        // Handle known parameter patterns explicitly
        if (json.contains("\\"nums\\"") && json.contains("\\"target\\"")) {
            // twoSum pattern: {"nums": [2, 7, 11, 15], "target": 9}
            int[] nums = TestRunner.extractIntArray(json, "nums");
            int target = TestRunner.extractIntValue(json, "target");
            params.add(nums);
            params.add(target);
        } else if (json.contains("\\"coins\\"") && json.contains("\\"amount\\"")) {
            // coin change pattern: {"coins": [1, 3, 4], "amount": 6}
            int[] coins = TestRunner.extractIntArray(json, "coins");
            int amount = TestRunner.extractIntValue(json, "amount");
            params.add(coins);
            params.add(amount);
        } else if (json.contains("\\"nums1\\"") && json.contains("\\"nums2\\"")) {
            // median of two sorted arrays pattern: {"nums1": [1, 3], "nums2": [2]}
            int[] nums1 = TestRunner.extractIntArray(json, "nums1");
            int[] nums2 = TestRunner.extractIntArray(json, "nums2");
            params.add(nums1);
            params.add(nums2);
        } else if (json.contains("\\"words\\"")) {
            // words array pattern: {"words": ["wrt", "wrf", "er", "ett", "rftt"]} for alien dictionary
            java.util.List<String> wordsList = extractStringList(json, "words");
            String[] words = wordsList.toArray(new String[0]);
            params.add(words);
        } else if (json.contains("\\"strs\\"")) {
            // strs array pattern: {"strs": ["eat", "tea", "tan", "ate", "nat", "bat"]} for group anagrams
            java.util.List<String> strsList = extractStringList(json, "strs");
            String[] strs = strsList.toArray(new String[0]);
            params.add(strs);
        } else if (json.contains("\\"nums\\"") && json.contains("\\"k\\"")) {
            // subarray sum equals k pattern: {"nums": [1, 1, 1], "k": 2}
            int[] nums = TestRunner.extractIntArray(json, "nums");
            int k = TestRunner.extractIntValue(json, "k");
            params.add(nums);
            params.add(k);
        } else if (json.contains("\\"matrix\\"")) {
            // matrix pattern: {"matrix": [[1,2,3],[4,5,6],[7,8,9]]} for rotate image, etc.
            int[][] matrix = TestRunner.extractIntMatrix(json, "matrix");
            params.add(matrix);
        } else if (json.contains("\\"nums\\"")) {
            // nums-only pattern: {"nums": [1, 1, 2]} for removeDuplicates, etc.
            int[] nums = TestRunner.extractIntArray(json, "nums");
            params.add(nums);
        } else if (json.contains("\\"height\\"")) {
            // height array pattern: {"height": [1, 8, 6, 2, 5, 4, 8, 3, 7]} for maxArea, trap, etc.
            int[] height = TestRunner.extractIntArray(json, "height");
            params.add(height);
        } else if (json.contains("\\"prices\\"")) {
            // prices array pattern: {"prices": [7, 1, 5, 3, 6, 4]} for stock problems
            int[] prices = TestRunner.extractIntArray(json, "prices");
            params.add(prices);
        } else if (json.contains("\\"x\\"")) {
            // single integer pattern: {"x": 123} for palindrome, reverse, etc.
            int x = TestRunner.extractIntValue(json, "x");
            params.add(x);
        } else if (json.contains("\\"n\\"")) {
            // single integer pattern: {"n": 5} for various problems
            int n = TestRunner.extractIntValue(json, "n");
            params.add(n);
        } else if (json.contains("\\"s\\"") && json.contains("\\"p\\"")) {
            // string s and p pattern: {"s": "abab", "p": "ab"} for find anagrams
            String s = TestRunner.extractStringValue(json, "s");
            String p = TestRunner.extractStringValue(json, "p");
            params.add(s);
            params.add(p);
        } else if (json.contains("\\"s\\"") && json.contains("\\"t\\"")) {
            // string pair pattern: {"s": "anagram", "t": "nagaram"} for valid anagram, etc.
            String s = TestRunner.extractStringValue(json, "s");
            String t = TestRunner.extractStringValue(json, "t");
            params.add(s);
            params.add(t);
        } else if (json.contains("\\"word1\\"") && json.contains("\\"word2\\"")) {
            // word1/word2 pattern: {"word1": "horse", "word2": "ros"} for edit distance
            String word1 = TestRunner.extractStringValue(json, "word1");
            String word2 = TestRunner.extractStringValue(json, "word2");
            params.add(word1);
            params.add(word2);
        } else if (json.contains("\\"root\\"")) {
            // TreeNode pattern: {"root": [3, 9, 20, null, null, 15, 7]} for tree problems
            int[] rootArray = extractIntArrayWithNulls(json, "root");
            TreeNode root = TestRunner.arrayToTreeNode(rootArray);
            params.add(root);
        } else if (json.contains("\\"beginWord\\"") && json.contains("\\"endWord\\"") && json.contains("\\"wordList\\"")) {
            // Word ladder pattern: {"beginWord": "hit", "endWord": "cog", "wordList": ["hot", "dot", "dog", "lot", "log", "cog"]}
            String beginWord = TestRunner.extractStringValue(json, "beginWord");
            String endWord = TestRunner.extractStringValue(json, "endWord");
            java.util.List<String> wordList = extractStringList(json, "wordList");
            params.add(beginWord);
            params.add(endWord);
            params.add(wordList);
        } else if (json.contains("\\"s\\"") && json.contains("\\"wordDict\\"")) {
            // Word break pattern: {"s": "catsanddog", "wordDict": ["cat", "cats", "and", "sand", "dog"]}
            String s = TestRunner.extractStringValue(json, "s");
            java.util.List<String> wordDict = extractStringList(json, "wordDict");
            params.add(s);
            params.add(wordDict);
        } else if (json.contains("\\"s\\"") && !json.contains("\\"t\\"") && !json.contains("\\"wordDict\\"")) {
            // single string pattern: {"s": "aab"} for palindrome partitioning, etc.
            String s = TestRunner.extractStringValue(json, "s");
            params.add(s);
        } else if (json.contains("\\"p\\"") && json.contains("\\"q\\"")) {
            // two tree pattern: {"p": [1, 2, 3], "q": [1, 2, 3]} for same-tree
            int[] pArray = extractIntArrayWithNulls(json, "p");
            int[] qArray = extractIntArrayWithNulls(json, "q");
            TreeNode p = TestRunner.arrayToTreeNode(pArray);
            TreeNode q = TestRunner.arrayToTreeNode(qArray);
            params.add(p);
            params.add(q);
        } else if (json.contains("\\\"a\\\"") && json.contains("\\\"b\\\"") && !json.contains("\\\"c\\\"")) {
            // two string pattern: {"a": "11", "b": "1"} for add-binary
            String a = TestRunner.extractStringValue(json, "a");
            String b = TestRunner.extractStringValue(json, "b");
            params.add(a);
            params.add(b);
        } else if (json.contains("\\\"intervals\\\"")) {
            // intervals pattern: {"intervals": [[1, 3], [2, 6], [8, 10], [15, 18]]} for merge-intervals
            int[][] intervals = TestRunner.extractIntArrayArray(json, "intervals");
            params.add(intervals);
        } else if (json.contains("\\\"l1\\\"") && json.contains("\\\"l2\\\"")) {
            // ListNode pattern: {"l1": [2, 4, 3], "l2": [5, 6, 4]} for add-two-numbers
            int[] l1Array = TestRunner.extractIntArray(json, "l1");
            int[] l2Array = TestRunner.extractIntArray(json, "l2");
            ListNode l1 = TestRunner.arrayToListNode(l1Array);
            ListNode l2 = TestRunner.arrayToListNode(l2Array);
            params.add(l1);
            params.add(l2);
        } else {
            // No fallback - fail with clear error message
            throw new RuntimeException("Unsupported parameter pattern in JSON: " + json + ". Please add explicit handling for this pattern.");
        }
        
        return params.toArray();
    }
    
    private static int[] extractIntArray(String json, String key) {
        String pattern = "\\"" + key + "\\"\\\\s*:\\\\s*\\\\[([^\\\\]]+)\\\\]";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher m = p.matcher(json);
        if (m.find()) {
            String arrayContent = m.group(1);
            String[] elements = arrayContent.split(",");
            int[] result = new int[elements.length];
            for (int i = 0; i < elements.length; i++) {
                result[i] = Integer.parseInt(elements[i].trim());
            }
            return result;
        }
        return new int[0];
    }
    
    private static String extractStringValue(String json, String key) {
        String pattern = "\\"" + key + "\\"\\\\s*:\\\\s*\\"([^\\"]*)\\\"";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher m = p.matcher(json);
        if (m.find()) {
            return m.group(1);
        }
        throw new RuntimeException("Could not find key: " + key);
    }
    
    private static java.util.List<String> extractStringList(String json, String key) {
        String pattern = "\\"" + key + "\\"\\\\s*:\\\\s*\\\\[([^\\\\]]+)\\\\]";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher m = p.matcher(json);
        if (m.find()) {
            String arrayContent = m.group(1);
            String[] elements = arrayContent.split(",");
            java.util.List<String> result = new java.util.ArrayList<>();
            for (int i = 0; i < elements.length; i++) {
                String element = elements[i].trim();
                // Remove quotes from string elements
                if (element.startsWith("\\"") && element.endsWith("\\"")) {
                    element = element.substring(1, element.length() - 1);
                }
                result.add(element);
            }
            return result;
        }
        return new java.util.ArrayList<>();
    }
    
    private static int[] extractIntArrayWithNulls(String json, String key) {
        String pattern = "\\"" + key + "\\"\\\\s*:\\\\s*\\\\[([^\\\\]]+)\\\\]";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher m = p.matcher(json);
        if (m.find()) {
            String arrayContent = m.group(1);
            String[] elements = arrayContent.split(",");
            int[] result = new int[elements.length];
            for (int i = 0; i < elements.length; i++) {
                String element = elements[i].trim();
                if (element.equals("null")) {
                    result[i] = Integer.MAX_VALUE; // Use MAX_VALUE as null marker
                } else {
                    result[i] = Integer.parseInt(element);
                }
            }
            return result;
        }
        return new int[0];
    }
    
    """

            lines.insert(last_brace_line, main_method)
            wrapped_user_code = "\n".join(lines)
        else:
            print(f"‚ùå [JAVA WRAPPER] Could not find class closing brace")
            wrapped_user_code = cleaned_code
    else:
        print(f"üîß [JAVA WRAPPER] User has class Solution (no public), using as-is")
        wrapped_user_code = cleaned_code

    # Create the complete wrapper
    java_wrapper = f"""import java.util.*;
import java.lang.reflect.*;
{user_imports_str}

// VersionControl API for first-bad-version problem
class VersionControl {{
    private static int badVersion = 0;
    
    public static void setBadVersion(int bad) {{
        badVersion = bad;
    }}
    
    public static boolean isBadVersion(int version) {{
        return version >= badVersion;
    }}
}}

// TreeNode definition for binary tree problems
class TreeNode {{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {{}}
    TreeNode(int val) {{ this.val = val; }}
    TreeNode(int val, TreeNode left, TreeNode right) {{
        this.val = val;
        this.left = left;
        this.right = right;
    }}
}}

// ListNode definition for linked list problems
class ListNode {{
    int val;
    ListNode next;
    ListNode() {{}}
    ListNode(int val) {{ this.val = val; }}
    ListNode(int val, ListNode next) {{ this.val = val; this.next = next; }}
}}

// Main wrapper class containing all helper methods
class TestRunner {{
    // Helper method to serialize TreeNode to array format (level-order)
    public static void serializeTreeNode(TreeNode root, java.util.List<Object> result) {{
        if (root == null) {{
            return;
        }}
        
        java.util.Queue<TreeNode> queue = new java.util.LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {{
            TreeNode node = queue.poll();
            if (node == null) {{
                result.add(null);
            }} else {{
                result.add(node.val);
                queue.offer(node.left);
                queue.offer(node.right);
            }}
        }}
        
        // Remove trailing nulls
        while (!result.isEmpty() && result.get(result.size() - 1) == null) {{
            result.remove(result.size() - 1);
        }}
    }}

    // Helper method to extract 2D int array from JSON
    public static int[][] extractIntArrayArray(String json, String key) {{
        String pattern = "\\"" + key + "\\"\\\\s*:\\\\s*\\\\[(.*?)\\\\](?=\\\\s*[,}}])";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern, java.util.regex.Pattern.DOTALL);
        java.util.regex.Matcher m = p.matcher(json);
        if (m.find()) {{
            String arrayContent = m.group(1);
            // Parse nested arrays [[1,2],[3,4]] format
            java.util.List<int[]> arrays = new java.util.ArrayList<>();
            String[] subArrays = arrayContent.split("\\\\],\\\\s*\\\\[");
            for (String subArray : subArrays) {{
                subArray = subArray.replaceAll("[\\\\[\\\\]]", "").trim();
                if (!subArray.isEmpty()) {{
                    String[] elements = subArray.split(",");
                    int[] arr = new int[elements.length];
                    for (int i = 0; i < elements.length; i++) {{
                        arr[i] = Integer.parseInt(elements[i].trim());
                    }}
                    arrays.add(arr);
                }}
            }}
            return arrays.toArray(new int[0][]);
        }}
        return new int[0][];
    }}

    // Helper method to convert int array to ListNode
    public static ListNode arrayToListNode(int[] arr) {{
        if (arr == null || arr.length == 0) return null;
        
        ListNode head = new ListNode(arr[0]);
        ListNode current = head;
        
        for (int i = 1; i < arr.length; i++) {{
            current.next = new ListNode(arr[i]);
            current = current.next;
        }}
        
        return head;
    }}

    // Helper method to convert int array to TreeNode
    public static TreeNode arrayToTreeNode(int[] arr) {{
        if (arr.length == 0 || arr[0] == Integer.MAX_VALUE) return null;
        
        TreeNode root = new TreeNode(arr[0]);
        java.util.Queue<TreeNode> queue = new java.util.LinkedList<>();
        queue.offer(root);
        
        int i = 1;
        while (!queue.isEmpty() && i < arr.length) {{
            TreeNode current = queue.poll();
            
            // Left child
            if (i < arr.length) {{
                if (arr[i] != Integer.MAX_VALUE) {{
                    current.left = new TreeNode(arr[i]);
                    queue.offer(current.left);
                }}
                i++;
            }}
            
            // Right child
            if (i < arr.length) {{
                if (arr[i] != Integer.MAX_VALUE) {{
                    current.right = new TreeNode(arr[i]);
                    queue.offer(current.right);
                }}
                i++;
            }}
        }}
        
        return root;
    }}

    // Helper method to extract int value from JSON
    public static int extractIntValue(String json, String key) {{
        String pattern = "\\"" + key + "\\"\\\\s*:\\\\s*(\\\\d+)";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher m = p.matcher(json);
        return m.find() ? Integer.parseInt(m.group(1)) : 0;
    }}

    // Helper method to extract string value from JSON
    public static String extractStringValue(String json, String key) {{
        String pattern = "\\"" + key + "\\"\\\\s*:\\\\s*\\"([^\\"]*)\\\"";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher m = p.matcher(json);
        return m.find() ? m.group(1) : "";
    }}

    // Helper method to extract int array from JSON
    public static int[] extractIntArray(String json, String key) {{
        String pattern = "\\"" + key + "\\"\\\\s*:\\\\s*\\\\[(.*?)\\\\]";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher m = p.matcher(json);
        if (m.find()) {{
            String arrayContent = m.group(1);
            if (arrayContent.trim().isEmpty()) {{
                return new int[0];
            }}
            String[] elements = arrayContent.split(",");
            int[] result = new int[elements.length];
            for (int i = 0; i < elements.length; i++) {{
                result[i] = Integer.parseInt(elements[i].trim());
            }}
            return result;
        }}
        return new int[0];
    }}

    // Helper method to extract 2D int matrix from JSON
    public static int[][] extractIntMatrix(String json, String key) {{
        String pattern = "\\"" + key + "\\"\\\\s*:\\\\s*\\\\[(.*?)\\\\](?=\\\\s*[,}}])";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern, java.util.regex.Pattern.DOTALL);
        java.util.regex.Matcher m = p.matcher(json);
        if (m.find()) {{
            String arrayContent = m.group(1);
            // Parse nested arrays [[1,2],[3,4]] format
            java.util.List<int[]> arrays = new java.util.ArrayList<>();
            String[] subArrays = arrayContent.split("\\\\],\\\\s*\\\\[");
            for (String subArray : subArrays) {{
                subArray = subArray.replaceAll("[\\\\[\\\\]]", "").trim();
                if (!subArray.isEmpty()) {{
                    String[] elements = subArray.split(",");
                    int[] arr = new int[elements.length];
                    for (int i = 0; i < elements.length; i++) {{
                        arr[i] = Integer.parseInt(elements[i].trim());
                    }}
                    arrays.add(arr);
                }}
            }}
            return arrays.toArray(new int[0][]);
        }}
        return new int[0][];
    }}

    // Helper method to extract string array from JSON
    public static String[] extractStringArray(String json, String key) {{
        String pattern = "\\"" + key + "\\"\\\\s*:\\\\s*\\\\[(.*?)\\\\]";
        java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
        java.util.regex.Matcher m = p.matcher(json);
        if (m.find()) {{
            String arrayContent = m.group(1);
            if (arrayContent.trim().isEmpty()) {{
                return new String[0];
            }}
            String[] elements = arrayContent.split(",");
            String[] result = new String[elements.length];
            for (int i = 0; i < elements.length; i++) {{
                result[i] = elements[i].trim().replaceAll("\\"", "");
            }}
            return result;
        }}
        return new String[0];
    }}
}}

{wrapped_user_code}
"""

    return java_wrapper


def get_persistent_container(language: str):
    """Get or create a persistent container for the given language."""
    global _persistent_containers

    with _container_lock:
        container_name = f"{language}-runner"

        # Check if container exists and is running
        if container_name in _persistent_containers:
            try:
                container = _persistent_containers[container_name]
                container.reload()
                if container.status == "running":
                    print(
                        f"üêõ [DOCKER DEBUG] Reusing existing {language} container: {container.id[:12]}"
                    )
                    return container
            except Exception as e:
                print(f"üêõ [DOCKER DEBUG] Container {container_name} is dead: {e}")
                # Container is dead, remove from cache
                del _persistent_containers[container_name]

        # Create new persistent container
        print(
            f"üêõ [DOCKER DEBUG] Creating NEW {language} container - this should only happen at startup!"
        )
        config = LANGUAGE_CONFIG.get(language)
        if not config:
            raise ValueError(f"Unsupported language: {language}")

        docker_client = get_docker_client()

        # Remove existing container if it exists
        try:
            old_container = docker_client.containers.get(container_name)
            old_container.remove(force=True)
            print(f"üêõ [DOCKER DEBUG] Removed old {container_name} container")
        except:
            pass

        # Create new container with appropriate startup command
        startup_cmd = config.get("startup_command", "sleep infinity")
        print(
            f"üêõ [DOCKER DEBUG] Starting new {language} container with image {config['image']}"
        )
        print(f"üêõ [DOCKER DEBUG] Startup command: {startup_cmd}")

        # Allocate more resources for Java containers due to compilation overhead
        cpu_allocation = (
            1000000000 if language == "java" else 300000000
        )  # 1.0 vs 0.3 CPU cores

        container = docker_client.containers.run(
            config["image"],
            command=startup_cmd,
            name=container_name,
            detach=True,
            mem_limit=config.get("mem_limit", "128m"),
            nano_cpus=cpu_allocation,
            network_mode="none",
            security_opt=["no-new-privileges:true"],
            working_dir="/tmp",
            remove=False,
        )

        print(
            f"üêõ [DOCKER DEBUG] Created new {language} container: {container.id[:12]}"
        )

        # For Java containers, copy CompilationServer.java and wait for server to start
        if language == "java":
            try:
                import os
                import time

                # Copy CompilationServer.java to container
                server_path = os.path.join(
                    os.path.dirname(__file__), "CompilationServer.java"
                )
                with open(server_path, "r") as f:
                    server_code = f.read()

                import base64

                encoded_server = base64.b64encode(server_code.encode("utf-8")).decode(
                    "ascii"
                )
                copy_result = container.exec_run(
                    f"sh -c 'echo {encoded_server} | base64 -d > /tmp/CompilationServer.java'",
                    workdir="/tmp",
                )

                if copy_result.exit_code != 0:
                    print(
                        f"‚ùå [DOCKER DEBUG] Failed to copy CompilationServer.java: {copy_result.output.decode()}"
                    )
                else:
                    print(
                        f"üêõ [DOCKER DEBUG] CompilationServer.java copied to container"
                    )

                    # Check if CompilationServer compiles
                    print(f"üîß [DOCKER DEBUG] Testing CompilationServer compilation...")
                    compile_test = container.exec_run(
                        f"javac -cp /tmp CompilationServer.java",
                        workdir="/tmp",
                    )
                    if compile_test.exit_code != 0:
                        print(
                            f"‚ùå [DOCKER DEBUG] CompilationServer.java failed to compile: {compile_test.output.decode()}"
                        )
                    else:
                        print(
                            f"‚úÖ [DOCKER DEBUG] CompilationServer.java compiled successfully"
                        )

                    # Note: Skip execution test to avoid port conflicts since container already runs the server

                    # Wait for compilation server to start (up to 2 minutes)
                    print(
                        f"üîß [DOCKER DEBUG] Waiting for CompilationServer to start..."
                    )
                    for i in range(240):  # 240 * 0.5s = 120s timeout (2 minutes)
                        try:
                            # Progress indicator every 10 seconds
                            if i % 20 == 0:
                                elapsed = i * 0.5
                                print(
                                    f"üîß [DOCKER DEBUG] Detection progress: {elapsed:.1f}s elapsed, still searching..."
                                )

                            # Method 1: Try TCP connection test (simpler and more reliable)
                            tcp_test = container.exec_run(
                                "timeout 1 bash -c 'exec 3<>/dev/tcp/localhost/8901; echo \"test\" >&3; exec 3<&-; exec 3>&-'",
                                workdir="/tmp",
                            )
                            if tcp_test.exit_code == 0:
                                print(
                                    f"üî• [DOCKER DEBUG] TCP connection to port 8901 successful!"
                                )

                                # Verify server is ready via logs
                                logs = container.logs(tail=20).decode("utf-8")
                                if "Server listening on port 8901" in logs:
                                    print(
                                        f"‚úÖ [DOCKER DEBUG] CompilationServer is ready!"
                                    )
                                    container._java_compilation_server_ready = True
                                    break
                                else:
                                    print(
                                        f"üîß [DOCKER DEBUG] TCP works but server not ready yet"
                                    )

                            # Method 2: Use /proc filesystem as fallback
                            proc_list = container.exec_run(
                                "ls /proc/ | grep -E '^[0-9]+$'", workdir="/tmp"
                            )
                            if proc_list.exit_code == 0:
                                proc_ids = [
                                    p.strip() for p in proc_list.output.decode().split()
                                ]

                                if i % 40 == 0:  # Every 20 seconds
                                    print(
                                        f"üîß [DOCKER DEBUG] Found {len(proc_ids)} processes to check"
                                    )

                                for proc_id in proc_ids:
                                    cmdline_check = container.exec_run(
                                        f"cat /proc/{proc_id}/cmdline", workdir="/tmp"
                                    )
                                    if cmdline_check.exit_code == 0:
                                        cmdline = cmdline_check.output.decode()
                                        if "CompilationServer" in cmdline:
                                            print(
                                                f"üî• [DOCKER DEBUG] Found CompilationServer process {proc_id} with cmdline: {cmdline}"
                                            )

                                            # Verify server is ready via logs
                                            logs = container.logs(tail=20).decode(
                                                "utf-8"
                                            )
                                            if "Server listening on port 8901" in logs:
                                                print(
                                                    f"‚úÖ [DOCKER DEBUG] CompilationServer is ready!"
                                                )
                                                container._java_compilation_server_ready = (
                                                    True
                                                )
                                                break
                                            else:
                                                print(
                                                    f"üîß [DOCKER DEBUG] Process found but server not ready yet, logs: {logs[-200:]}"
                                                )

                                if (
                                    hasattr(container, "_java_compilation_server_ready")
                                    and container._java_compilation_server_ready
                                ):
                                    break
                        except Exception as e:
                            if i % 40 == 0:  # Every 20 seconds
                                print(
                                    f"üîß [DOCKER DEBUG] Detection attempt {i} failed: {e}"
                                )
                        time.sleep(0.5)
                    else:
                        print(
                            f"‚ùå [DOCKER DEBUG] Java compilation server failed to start within 2 minutes"
                        )
                        # Print recent container logs for debugging
                        try:
                            logs = container.logs(tail=20).decode("utf-8")
                            print(f"üîß [DOCKER DEBUG] Recent container logs:\n{logs}")
                        except:
                            print(
                                f"üîß [DOCKER DEBUG] Could not retrieve container logs"
                            )

            except Exception as e:
                print(
                    f"‚ùå [DOCKER DEBUG] Error setting up Java compilation server: {e}"
                )

        _persistent_containers[container_name] = container
        return container


def run_code_in_docker(
    request: DockerRunRequest, docker_client=None, use_fast_runner=None
):
    """Run code using persistent containers for fast execution."""
    import time

    # Initialize run_command to avoid UnboundLocalError
    run_command = None

    start_time = time.time()
    print(f"üêõ [DOCKER DEBUG] Starting {request.language} execution")
    print(f"üêõ [DOCKER DEBUG] Function name: {request.function_name}")
    print(f"üêõ [DOCKER DEBUG] Raw request.function_name: {repr(request.function_name)}")
    print(f"üêõ [DOCKER DEBUG] Request language: {repr(request.language)}")

    try:
        config = LANGUAGE_CONFIG.get(request.language)
        if not config:
            raise ValueError(f"Unsupported language: {request.language}")

        # Get persistent container
        container_start = time.time()
        container = get_persistent_container(request.language)
        container_time = (time.time() - container_start) * 1000
        print(f"üêõ [DOCKER DEBUG] Getting container took {container_time:.0f}ms")

        # Prepare code with wrapper template
        print(
            f"üêõ [DOCKER DEBUG] About to format wrapper template for {request.language}"
        )
        try:
            # Special processing for Java firstBadVersion to avoid class conflicts
            processed_code = request.code

            if (
                request.language == "java"
                and request.function_name == "firstBadVersion"
            ):
                # Remove "extends VersionControl" from user code if present to avoid conflicts
                processed_code = processed_code.replace(
                    "extends VersionControl", ""
                ).replace("  {", " {")
                print(f"üêõ [DOCKER DEBUG] Cleaned Java code for firstBadVersion")

            # Generate code based on language
            if request.language == "cpp":
                # Use dynamic wrapper generation for C++
                wrapped_code = generate_cpp_wrapper(
                    request.function_name, processed_code
                )
                print(
                    f"üîß [CPP WRAPPER] Generated dynamic wrapper for {request.function_name}"
                )
            elif request.language == "java":
                # Use dynamic wrapper generation for Java
                wrapped_code = generate_java_wrapper(
                    request.function_name, processed_code
                )
                print(
                    f"üîß [JAVA WRAPPER] Generated dynamic wrapper for {request.function_name}"
                )
            else:
                # All other languages use their universal wrapper templates
                # Use string replacement instead of .format() to avoid issues with ! characters
                wrapped_code = (
                    config["wrapper_template"]
                    .replace("{code}", processed_code)
                    .replace("{function_name}", request.function_name)
                )
            print(f"üêõ [DOCKER DEBUG] Wrapped code length: {len(wrapped_code)}")
        except Exception as e:
            print(f"üêõ [DOCKER DEBUG] Exception formatting wrapper: {e}")
            raise

        # Determine filename
        if request.language == "java":
            filename = "Solution.java"
        else:
            filename = f"solution{config['file_extension']}"

        # Write code to container using docker exec
        file_start = time.time()
        import base64

        encoded_code = base64.b64encode(wrapped_code.encode("utf-8")).decode("ascii")

        # Create file in container
        create_result = container.exec_run(
            f"sh -c 'echo {encoded_code} | base64 -d > /tmp/{filename}'",
            workdir="/tmp",
        )
        file_time = (time.time() - file_start) * 1000
        print(f"üêõ [DOCKER DEBUG] File creation took {file_time:.0f}ms")

        # Handle timeout error for file creation
        if create_result.exit_code == 124:
            return {
                "success": False,
                "output": None,
                "execution_time": 0,
                "error": f"File creation timed out",
            }

        if create_result.exit_code != 0:
            return {
                "success": False,
                "output": None,
                "execution_time": (time.time() - start_time) * 1000,
                "error": f"Failed to create file: {create_result.output.decode('utf-8')}",
            }

        print(
            f"üêõ [DOCKER DEBUG] File created successfully, proceeding to build commands..."
        )

        # Build command sequence
        commands = []
        print(f"üêõ [DOCKER DEBUG] Building commands...")

        # Add compilation step if needed
        if "compile_command" in config:
            if request.language == "java":
                # Try Java compilation server first, fallback to traditional compilation
                compilation_dir = use_java_compilation_server(container, wrapped_code)
                if compilation_dir:
                    print(
                        f"üî• [COMPILATION SERVER] Compilation successful, output in: {compilation_dir}"
                    )
                else:
                    # Fallback to traditional javac compilation
                    print(
                        f"‚ö†Ô∏è [COMPILATION SERVER] Server failed, falling back to traditional javac"
                    )
                    compile_cmd = config["compile_command"].format(filename=filename)
                    commands.append(compile_cmd)
                    compilation_dir = "/tmp"  # Use default directory for fallback
            elif request.language == "cpp":
                # Use smart caching for C++ compilation
                binary_path = compile_cpp_with_cache(
                    container, wrapped_code, request.function_name
                )
                if binary_path:
                    # Override run command to use the cached binary
                    run_command = binary_path
                else:
                    # Fallback to traditional g++ compilation
                    print(
                        f"‚ö†Ô∏è [CPP CACHE] Caching failed, falling back to traditional g++"
                    )
                    compile_cmd = config["compile_command"].format(filename=filename)
                    commands.append(compile_cmd)
                    print(f"üêõ [DOCKER DEBUG] Added C++ compile command: {compile_cmd}")
                    # Initialize run_command for fallback case
                    run_command = None
            else:
                # Other languages: compile normally
                compile_cmd = config["compile_command"].format(filename=filename)
                commands.append(compile_cmd)
                print(f"üêõ [DOCKER DEBUG] Added compile command: {compile_cmd}")

        # Add run command
        if request.language == "java" and "compile_command" in config:
            # For Java with compilation server, run from compilation directory
            run_command = (
                f"cd {compilation_dir}; "
                + config["run_command"].format(filename=filename)
                if "{filename}" in config["run_command"]
                else f"cd {compilation_dir}; " + config["run_command"]
            )
        elif request.language == "cpp" and run_command:
            # For C++ with cached binary, run_command is already set to binary path
            pass  # run_command already set by caching logic
        else:
            # Normal run command for other languages or C++ fallback
            if not run_command:  # Only set if not already set
                run_command = (
                    config["run_command"].format(filename=filename)
                    if "{filename}" in config["run_command"]
                    else config["run_command"]
                )

        print(f"üêõ [DOCKER DEBUG] Base run command: {run_command}")

        # Pass arguments based on language
        print(
            f"üêõ [DOCKER DEBUG] About to check language condition: {request.language} in ['python', 'javascript', 'java', 'cpp']"
        )
        if request.language in ["python", "javascript", "java", "cpp"]:
            print(f"üêõ [DOCKER DEBUG] ENTERING PYTHON/JS/JAVA/CPP BRANCH")
            # For Python, JavaScript, and Java, pass function name and input as separate arguments
            function_name = getattr(request, "function_name", "solution")
            print(
                f"üêõ [DOCKER DEBUG] Raw function_name from request: {repr(function_name)}"
            )
            print(f"üêõ [DOCKER DEBUG] Type of function_name: {type(function_name)}")
            print(
                f"üêõ [DOCKER DEBUG] Function name for {request.language}: {function_name}"
            )
            input_json = json.dumps(request.test_input).replace('"', '\\"')
            run_command += f' "{function_name}" "{input_json}"'
            print(f"üêõ [DOCKER DEBUG] Run command after args: {run_command}")
        else:
            # For other languages (C++), pass input as single argument
            input_json = json.dumps(request.test_input).replace('"', '\\"')
            run_command += f' "{input_json}"'

        commands.append(run_command)

        # Execute commands in container
        exec_start = time.time()
        full_command = " && ".join(commands)
        print(f"üêõ [DOCKER DEBUG] Executing: {full_command}")
        print(
            f"üêõ [DOCKER DEBUG] Request function_name: {getattr(request, 'function_name', 'NOT SET')}"
        )
        import sys

        sys.stdout.flush()

        exec_result = container.exec_run(f"sh -c '{full_command}'", workdir="/tmp")

        exec_time = (time.time() - exec_start) * 1000
        execution_time = (time.time() - start_time) * 1000
        print(
            f"üêõ [DOCKER DEBUG] Command execution took {exec_time:.0f}ms, total time {execution_time:.0f}ms"
        )

        # Handle timeout error (exit code 124 from shell timeout command)
        if exec_result.exit_code == 124:
            return {
                "success": False,
                "output": None,
                "execution_time": 0,  # Timeout value removed
                "error": f"Code execution timed out. Your solution may have an infinite loop or be too slow.",
            }

        if exec_result.exit_code == 0:
            try:
                logs = exec_result.output.decode("utf-8")

                # Find JSON output line
                print(f"üêõ [DOCKER DEBUG] Raw logs: {logs}")
                output_lines = [
                    line.strip() for line in logs.strip().split("\n") if line.strip()
                ]

                for line in reversed(output_lines):
                    try:
                        output_data = json.loads(line)
                        print(f"üêõ [DOCKER DEBUG] Parsed JSON: {output_data}")
                        if isinstance(output_data, dict) and "result" in output_data:
                            return {
                                "success": True,
                                "output": output_data.get("result"),
                                "execution_time": output_data.get(
                                    "execution_time", execution_time
                                ),
                                "error": output_data.get("error"),
                            }
                    except json.JSONDecodeError:
                        continue

                return {
                    "success": False,
                    "output": None,
                    "execution_time": execution_time,
                    "error": f"Could not parse JSON output. Raw logs: {logs}",
                }

            except Exception as e:
                return {
                    "success": False,
                    "output": None,
                    "execution_time": execution_time,
                    "error": f"Failed to parse output: {str(e)}",
                }
        else:
            logs = exec_result.output.decode("utf-8")
            return {
                "success": False,
                "output": None,
                "execution_time": execution_time,
                "error": f"Execution failed: {logs}",
            }

    except Exception as e:
        execution_time = (time.time() - start_time) * 1000
        print(f"üêõ [DOCKER DEBUG] MAIN EXCEPTION CAUGHT: {str(e)}")
        print(f"üêõ [DOCKER DEBUG] Exception type: {type(e)}")
        import traceback

        print(f"üêõ [DOCKER DEBUG] Traceback: {traceback.format_exc()}")
        return {
            "success": False,
            "output": None,
            "execution_time": execution_time,
            "error": f"Error: {str(e)}",
        }


def cleanup_persistent_containers():
    """Clean up all persistent containers."""
    global _persistent_containers

    with _container_lock:
        for container_name, container in _persistent_containers.items():
            try:
                container.remove(force=True)
                print(f"Cleaned up container: {container_name}")
            except Exception as e:
                print(f"Error cleaning up container {container_name}: {e}")

        _persistent_containers.clear()


# Test it
if __name__ == "__main__":
    from backend.models.questions import DockerRunRequest

    test_request = DockerRunRequest(
        code="class Solution { public int[] solution(int[] nums, int target) { for (int i = 0; i < nums.length; i++) { for (int j = i + 1; j < nums.length; j++) { if (nums[i] + nums[j] == target) { return new int[]{i, j}; } } } return new int[]{}; } }",
        language="java",
        test_input={"nums": [2, 7, 11, 15], "target": 9},
        timeout=5,
    )

    result = run_code_in_docker(test_request)
    print(json.dumps(result, indent=2))
